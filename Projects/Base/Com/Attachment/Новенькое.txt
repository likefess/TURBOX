
14.08.2018

- Чтобы выполнить некоторые действия при создании новой записи в картотеке, нужно перекрыть метод DoCreateRecord, например:

    proc DoCreateRecord(aRec :Rec_Unit);
      aRec.IsCurrency.Value = True;
    end;

  (см. пример Biz.Tab.Ref.UCurrencies)

  Чтобы выполнить некоторые действия при создании новой записи в картотеке, открытой на выбор из IEdit
  (чтобы новая запись удовлетворяла lookup-фильтру), нужно для IEdit указать свойство OnCreateRecord, например:

    EditType.OnCreateRecord =
      proc(aRec :Rec.IRecord)
        ICalendarType(aRec).Комментарий.Value = 'текстовый комментарий';
      end;

  (см. пример Samples.ComSampleEditor).

  Обработчик OnCreateRecord из IEdit добавляется к обработчику DoCreateRecord и вызывается последовательно после обработчика
  картотеки.
  Обратите внимание, что на текущий момент параметр aRec всегда нужно описывать как Rec.IRecord, иначе не будет компилироваться.
  Из-за этого внутри приходится использовать приведение типа. Но в будущем этого скорее всего можно будет избежать.

16.08.2018

- Для класса IStruct добавлен метод

    func AddExtraField( aName :String; aType : VarTypes; aRecordClass :Class Rec.IRecord = nil ) :IField;

  назначение совпадает с аналогичным методом класса IRecord.

- Для метода AddFieldCol класса IFrame добавлены необязательные параметры Jump и JumpFormClass:

    func AddFieldCol( aLabel :String = ""; aWidth :Numeric = 0;  aField :IValue;
      aLookupField :String = ""; aCardFileClass :class Frm.ICardForm = nil;
      aJump :Boolean = false; aJumpFormClass :class Frm.IForm = nil ) :Ctrl.IControl;

  Назначение параметров совпадает с аналогичными параметрами методов AddEdit и AddFieldEdit (параметр Jump = True означает,
  что рядом с соответствующим полем необходимо отобразить "кнопку перескока"; в параметре JumpFormClass можно указать форму,
  в которой нужно открыть соответствующий объект; если форма не задана, то объект открывается в форме по-умолчанию).

- Для класса IFrame добавлен метод

    func AddButtonCol( aIconName :String; aProcessing :proc(aIndex :Integer) ) :Ctrl.IButton;

  Метод добавляет в подтаблицу кнопку стандартных размеров с заданной иконкой и обработчиком нажатия.
  Обратите внимание, что в данном случае обработчик нажатия обязательно должен иметь параметр Index - это
  индекс строки в которой произошло нажатие.

  Например, чтобы в строку подтаблицы добавить кнопку, удаляющую текущую строку, нужно написать:

    FrameTab.AddButtonCol('DeleteItem',
      proc(aIndex :Integer)
        Subt.Delete(aIndex);
      end
    );

- Для класса IStruct добавлены обработчики

    proc DoCreate;

    proc DoDelete;

  Обработчики нужны для описания действий, которые необходимо сделать при добавлении новой / удалении строки
  Например:

    proc DoCreate;
      ДатаВстроке.Value = Today;
    end;

    proc DoDelete;
      if ФлагВСтроке.Value = True then
        Sys.Errors.Err('Запрещено удалять данную строку');
      end;
    end;

- Для класса ISubtable добавлена возможность указать пересчеты по событию "после удаления" (const peAfterDelete). Например:

    Init;
      ...
      Positions = AddSubtable( "Position", Rec.Invoice_Position );
      Positions.AddProcessing(@EvalTotal, Positions.peAfterDelete);
      ...
    end;

    proc EvalTotal;
      Total = Positions.SumOfField("Sum");
    end;

17.08.2018

- рефакторинг метода SetWidth: теперь для установки размера (ширины) контрола нужно устанавливать параметр Width

    vControl.Width = ...

  Изменение размера контрола работает также при открытой форме.

21.08.2018

- рефакторинг метода SetCellFormat класса IEdit: теперь для установки формата клетки нужно устанавливать параметр CellFormat

    vEdit.CellFormat = const.NumericFormat;

- Расширены возможности применения классов IPeriodicField и IPeriodicEditor. Теперь можно работать не только с числовыми
  периодическими полями, но и с полями других типов. Для этого изменился формат конструктора:

    func ShowPeriodField(aField :IPeriodicField; aPrototype :Ctrl.IEdit; aFieldWidth :Numeric = 0) :Frm.IPeriodicEditor;

  В качестве параметра Prototype нужно передать объект IEdit, из которого возьмутся все необходимые настройки (формат,
  картотека, фильтр и т.п.). Можно передать как существующий объект, отображаемый на форме (например, текущее значение курса),
  так и специально созданный объект:

    proc ОткрытьБланкИсторииКурсов;
      var vEdit :IEdit;

      vEdit = IEdit.CreateEx(, 30, '@Курс', const.NumericFormat);
      vEdit.FieldFormat = '0.00';
      Frm.IPeriodicEditor.ShowPeriodField(FRecord.Курс, vEdit);
    end;

  Если параметр FieldWidth задан, то ширина колонки со значением берется из него, иначе из ширины Prototype.

- Изменилась сортировка на форме IPeriodicEditor. Теперь актуальные значения находятся сверху

28.08.2018

- Добавлено событие OnVerify для IValue (поля документа, переменной и т.п.). Это аналог лимитов реквизитов из машины реквизитов.
  Для регистрации обработчика нужно вызвать метод AddOnVerify, например:

    Date.AddOnVerify(@VerifyDate);

    proc VerifyDate(aValue :Variant);
      if aValue = nil then
        Err('Поле "Дата" не может быть пустым');
      end;
    end;

  Событие OnVerify происходит до установки значения, поэтому внутри обработчика можно узнать как текущее значение (Date.Value), так
  и новое (aValue).

- Реализована поддержка периодических структур. Работать с ними нужно также, как и с обычными подтаблицами, только класс структуры
  нужно создавать на основе IPeriodicStruct. В этой структуре есть предопределенная переменная Date для работы с индексом и Value
  (используется для периодических полей, для структур не задействована).
  При вставке новой строки в периодическую подтаблицу вставляется новая структура с индексом Today.
  Пример можно посмотреть в форме Первичка.Frm.Данные.СубъектФЛ.

31.08.2018

- Для классов IEdit и IStatic добавлено свойство

     Wrap :Logical;

  Управляет одноименным свойством клетки шаблона. Для IStatic и IEdit в шапке документа свойство по умолчанию True. Для IEdit в
  табличной части - False.

- В конструктор класса ISubtable и интерфейсный метод AddSubtable добавлено свойство Filter

    func CreateEx(aStructClass :Class IStruct = IStruct; aSubtableName :String = nil; aFilter :String = '') :ISubtable;

    func AddSubtable( aName :String; aStructClass :Class IStruct; aFilter :String = '' ) :ISubtable;

  С помощью фильтра можно разбивать физическую подтаблицу на несколько логических. В событии OnCreate класса StructClass нужно
  обеспечить, чтобы созданная строка попадала под фильтр. Например:

    ПозицииОбычные = AddComp(ISubtable.CreateEx( PositionNormalClass, "Позиции", 'ТипДвижения = ' + Str(ТипДвиженияОбычный) ));

    proc DoCreate;
      ТипДвижения.Inner = ТипДвиженияОбычный;
    end;

03.09.2018

- Теперь прямой вызов метода AddProcessing запрещен. Вместо этого нужно использовать методы:

  IValue (IVar, IField, ...)
    proc AddOnInput(aProc :TOnInput);
    proc AddOnVerify(aProc :TOnVerify);

  IRecord
    proc AddOnCreate(aProc :proc);
    proc AddOnDelete(aProc :proc);
    proc AddOnDuplicate(aProc :proc);
    proc AddOnPost(aProc :proc);
    proc AddOnCreate(aProc :proc);

  IStruct
    proc AddOnCreate(aProc :proc);
    proc AddOnDelete(aProc :proc);

  ISubtable
    proc AddOnAfterDelete(aProc :proc);

  IButton + IStatic
    proc AddOnClick(aProc :proc);
    proc AddOnClickEx(aProc :TOnClickEx);

  IEdit
    proc AddOnVerify(aProc :TOnVerify);
    proc AddOnVerifyEx(aProc :TOnVerifyEx);
    proc AddOnInput(aProc :TOnInput);
    proc AddOnInputEx(aProc :TOnInputEx);

  ICheckBox
    proc AddOnInput(aProc :TOnInput);
    proc AddOnInputEx(aProc :TOnInputEx);

  IForm
    proc AddOnShow(aProc :proc);
    proc AddOnClose(aProc :proc);

  ICardForm
    proc AddOnCreateRecord(aProc :TOnCreateRecord);

  IReportForm
    proc AddOnRepCancel(aProc :proc);
    proc AddOnBeforePrepare(aProc :proc);
    proc AddOnBeforeBuild(aProc :proc);
    proc AddOnAfterBuild(aProc :proc);

07.09.2018

- Добавлена возможность настраивать контекстное меню строки таблицы для веб-клиента. Для этого в классе ICardFile добавлено свойство

    RowCommands                       :Ctrl.IButton[];

  и метод

  proc AddCommand( aCommand :Ctrl.IButton; aIndex :Integer = 0 );

  Если параметр Index = 0, то добавление идет в конец, если отрицательный, то на i-е место с конца.
  Для всех картотек по-умолчанию в контекстное меню добавлены 2 команды: редактировать и удалить

    proc InitRowCommands;
      CardFile.AddCommand(IButton.CreateCommand(consts.cmdEditItem));
      CardFile.AddCommand(IButton.CreateCommand(consts.cmdDeleteItem));
    end;

  Чтобы изменить состав контекстного меню в конкретной картотеке нужно в наследниках перекрыть метод InitRowCommands и добавить
  свои команды, либо полностью изменить меню.

09.09.2018

- Метод CompName и поле FName класса IComponent переименованы в CompID и FID соответственно.

14.09.2018

- Метод AddCol класса ICardForm объявлен Deprecated, вместо него нужно использовать

    func AddFieldCol( aCaption :String = ""; aWidth :Numeric; aCellFormat :CellFormats = CommonFormat; aField :IValue; aLookupField :String = nil ) :IControl;

  Формат нового метода совпадает со старым, но параметр Width имеет размерность мм, а не пискели, как старый метод.

09.10.2018

- Для класса IStruct добавлено событие OnRead (по аналогии с IRecord). Действия, которые нужно выполнить
  при инициализации позиции (например, расчет значений вычислимых переменных), нужно делать в обработчике
  DoRead или регистрировать с помощью метода AddOnRead.

    proc DoRead;
      inherited DoRead;
      ИнициализацияПеременных;
    end;

  или

    AddOnRead(@ИнициализацияПеременных);

23.10.2018
Адаскин
- Для классов ICheckBox и IEdit изменена логика работы обработчика OnOutput
  - метод OutputFuncEx переименован в OutputFuncCol
  - методы OutputFunc и OutputFuncCol вызываются только для Action in [Output, Copy]
  - добавлены новые методы OutputFuncEx и OutputFuncColEx, которые получают Action как параметр и вызываются всегда

25.10.2018

Филатов
- Для класса IForm добавлено свойство HelpContext. Если свойство задано, то соответствующий топик открывается из формы
  при нажатии F1 и клике на кнопке Помощь.

  См. пример для формы "Договор покупки" (ТиС.Frm.Документы.Покупки.ДоговорПокупки):

    var HelpContext     :String := 'ТиС.Торговля.Операции проводимые в системе Торговля.Покупка ТМЦ.Договор покупки';

30.10.2018
Адаскин
- Изменён формат методов OutputFuncEx и OutputFuncColEx, в них появились параметры aValue и aFormat

Филатов
- Теперь пересчеты, происходящие при изменении значения поля (OnInput) происходят только если значение действительно изменилось.
  Если нужно вызвать какие то действия в любом случае, даже если значение не меняется, то нужно использовать новое событие OnTouch.
  Регистрация обработчиков осуществляется методом:

    proc AddOnTouch( aCondition :TConditionFunc = nil; aProc :TOnInput );

06.11.2018
Адаскин
- Для класса IReportForm добавлен флаг ShowReportForm. Если он установлен, то при вызове метода Build() отчёт показывается на экране
  и обработчики метода вызываются только если нажата кнопка "Заполнить из отчёта".

08.11.2018

Филатов
- Изменился приоритет бланков-редакторов при открытии записи из картотеки. Теперь если в картотеке указан параметр EditorClass, то
  именно он используется в качестве формы. Если параметр EditorClass не указан, то открывается форма, указанная в Rec классе. Т.о.
  теперь в базовых картотеках, да и вообще в большинстве картотек, не нужно указывать EditorClass. Исключения составляют случаи,
  когда нужно чтобы из конкретной картотеки записи открывались в конкретной форме. Например спец.картотека всех процессов с формой
  "без настройки".

- Для класса ICardForm добавлено новое свойство

    var RecordClasses             :Class[] Rec.IRecord

  Это список классов записей, которые могут быть созданы из данной картотеки. По умолчанию это свойство заполняется из RecordClass
  картотеки, т.е. в простых случаях это свойство специально указывать не надо.
  Если свойство RecordClasses указано, и в массиве более одного элемента, то при создании новой записи из картотеке появляется
  список доступных RT-классов и уже при выборе конкретного RT-класса открывается нужная форма.
  Новое свойство используется в методе AddDocumentsTab класса ТиС.Frm.Данные.БазовыйТорговля. Пример вызова можно посмотреть в
  классе ТиС.Frm.Данные.Склад.

- Для класса ICardForm добавлены новые свойства

    CanOpen   :Logical := True;
    CanEdit   :Logical := False;

  Т.о. теперь inplace-редактирование в картотеке определяется не свойством EditorClass, а флагом CanEdit.

12.11.2018

Филатов
- Свойство Hierarchical теперь нужно устанавливать у объекта ICardForm, а не у ICardFile.

13.11.2018

Филатов
- Поле RTClass в записях изменило тип на String.

  Теперь по-умолчанию класс IRecord определяется исходя из поля RTClass в ТипеПроцесса (TypeProc).
  Поле RTClass самой записи по умолчанию не используется и не заполняется.
  В тех случаях, когда нужно задействовать поле RTClass, настройщик самостоятельно должен настроить
  сохранение нужного значения в поле.
  Если поле RTClass записи используется, то оно более приоритетно, чем TypeProc.RTClass.

  ВНИМАНИЕ! Для корректной работы необходимо и достаточно запустить конвертацию из панели
  Администрирование - Настройки - Общие настройки - Заполнить RTClass

15.11.2018
Адаскин
- Изменения в IReportForm:
   - Добавлены методы ColIterator, RowIterator, TabIterator :TReportIterator идентичные параметрам
   метода Build() и вызывающиеся при обходе по колонкам, строкам и таблицам отчёта соответственно.
   Если метод-Iterator возвращает false, то нижележащие методы не вызываются.
   Т.е. если для некоторой таблицы TabIterator вернул false, то для неё RowIterator и ColIterator
   вызваны не будут.
   - Добавлен метод OpenGroups влияющий на то, осуществляется ли обход до конца иерархии или только в текущей группе.
   - Удалён метод ShowReportForm.
   - Из метода Build() удалён 4ый параметр

  Таким образом, если требуется отобразить отчёт на экране и по нажатии кнопки "Заполнить из отчёта"
  выполнить какие-либо действия, нужно писать:
  vRep.RowIterator = func (Rep :Rep.IReport) :Logical ... end;
  vRep.Show(StackedWindow);

  Либо, если требуется организовывать обход отчёта самостоятельно:
  vRep.BeforeClose = proc(aSender :Frm.IForm; aModalResult :Integer) ... end;
  vRep.Show(StackedWindow);

16.11.2018

Филатов
- Для класса ICardForm добавлено новое свойство

    var ShowHierarchy             :Logical = FShowHierarchy set @SetShowHierarchy;

  С помощью этого свойства можно извне управлять показом иерархии для иерархической картотеки.
  В сеттере SetShowHierarchy можно обрабатывать установку этого свойства, например:

    proc SetShowHierarchy(aShowHierarchy :Logical);
      inherited SetShowHierarchy(aShowHierarchy);
      Filter = If(aShowHierarchy, '' , 'IsGroup = 0');
    end;

- Для класса IEdit добавлено новое свойство

    var ShowHierarchy             :Logical := True;

  С помощью данного свойства можно задать умолчание, с которым откроется картотека из этого поля
  для выбора. Например:

    Склад = AddFieldEdit("@Склад", FRecord.ОбщПроцессОткуда,, "Name", Tab.Данные.Склады, True);
    Склад.ShowHierarchy = False;

20.11.2018

Бабань
- В процедуру IForm.OpenTab (открытие картотеки в дочерней форме) добавлены шестой и седьмой параметры.
  Шестой параметр theClasses :Class[] Rec.IRecord задаёт список типов записей (Rec-классов), который
    предлагается для выбора при вводе новой записи в картотеку.
  Седьмой параметр anOnCreateRecord :TOnCreateRecord задаёт дополнительный обработчик, который вызывается при
    создании новой записи из открытой картотеки. Этот обработчик удобно использовать для заполнения значений полей
    по умолчанию. Обработчик добавляется к списку обработчиков типа peCreate.
  Оба параметра необязательны.
  Параметры следует использовать для настройки поведения картотек, открываемых из документов по сервисным командам.
  Например, по одной из сервисных команд из формы "Наше предприятие" вызывается процедура, содержащая следующее:
    OpenTab( Tab.Данные.Процессы, локФильтр,,,,
      [Rec.Документы.Продажи.ДоговорПродажи, Rec.Документы.Продажи.ДоговорПродажиПоКомиссии], @_NewContract );
  ...
  proc _NewContract( aRec :IRecord );
    with Rec_BaseProcess(aRec) do
      Company_ = FRecord.InternalRecord;
    end;
  end;

22.11.2018

Филатов
- Добавлен новый вид пересчета при изменении значения OnManualInput. Пересчет срабатывает, если изменение значения было
  произведено вручную, а не в результате другого пересчета. Регистрация обработчиков осуществляется методом:

    proc AddOnManualInput( aCondition :TConditionFunc = nil; aProc :TOnInput );

  Обработчики для OnInput, OnTouch, OnManualInput срабатывают в порядке их регистрации.

- В класс IValue добавлено новое свойство:

    var Manually   :Logical;

  Этот флаг нужно устанавливать перед установкой значения поля для эмуляции ручного ввода. Например при импорте данных
  из внешнего источника. После установки значения поля, помеченного флагом Manually, пересчеты OnManualInput сработают.

    ТМЦ.Manually = True;
    ТМЦ.Inner = <ТМЦ1>

  Снимать флаг обратно не требуется.


27.11.2018

Филатов
- Добавлен новый класс-компонент Ctrl.IColumnsGroup. Он позволяет группировать заголовки колонок табличной части.
  Например:

      with AddFrame(IFrame.CreateEx("FramePosition")) do
        Subtable = FRecord.Positions;
        vDefPos = FRecord.Positions.DefStruct;

        AddFieldCol(, 80, vDefPos.Product, 'Name', Tab.Products);

        vGroup = AddColGroup('Цифры');
        vGroup.AddFieldCol(, 20, vDefPos._Price);
        vGroup.AddFieldCol('Колич.', 20, vDefPos._Amount);

        vSubGroup = vGroup.AddColGroup('Сумма');
        vSubGroup.AddFieldCol(, 25, vDefPos._Sum);
        vSubGroup.AddFieldCol(, 25, vDefPos._Cur);
      end;

  +---------+-----------------------------------------+
  |         |                Цифры                    |
  |         +--------+------------+-------------------+
  |  Товар  |        |            |       Сумма       |
  |         |  Цена  | Количество +--------+----------+
  |         |        |            | Сумма  |  Валюта  |
  +---------+--------+------------+--------+----------+

- Добавлена интерфейсная функция

    func AddColGroup( aLabel :String ) :Ctrl.IColumnsGroup;

  Если свойство Label не указано, то HasCaption = False (см.ниже) и соответствующий
  контрол не отображается.


- В класс Ctrl.IControl добавлено новое свойство

    var HasCaption   :Logical;

  С помощью него можно указать, есть ли для данного контрола контрол с заголовком или нет.
  Пока свойство поддержано только для табличных контролов.
  Например для предыдущего примера можно убрать третью строку заголовка:

      with AddFrame(IFrame.CreateEx("FramePosition")) do
        Subtable = FRecord.Positions;
        vDefPos = FRecord.Positions.DefStruct;

        AddFieldCol(, 80, vDefPos.Product, 'Name', Tab.Products);

        vGroup = AddColGroup('Цифры');
        vGroup.AddFieldCol(, 20, vDefPos._Price);
        vGroup.AddFieldCol('Колич.', 20, vDefPos._Amount);

        vSubGroup = vGroup.AddColGroup('Сумма');
        vSubGroup.AddFieldCol(, 25, vDefPos._Sum).HasCaption = False;
        vSubGroup.AddFieldCol(, 25, vDefPos._Cur).HasCaption = False;
      end;

  +---------+-----------------------------------------+
  |         |                Цифры                    |
  |  Товар  +--------+------------+-------------------+
  |         |  Цена  | Количество |       Сумма       |
  +---------+--------+------------+--------+----------+

- Добавлен новый базовый класс-компонент Ctrl.IControlsGroup. Он является базовым классом
  для IFrame и IColumnsGroup. В него перемещены высокоуровневые функции (AddFieldCol, AddEdit и т.п.)

- В класс IFrame добавлены новые свойства

    var CanInsert  :Logical;
    var CanDelete  :Logical;

  Свойства имеют смысл только для табличных частей.

- Вместо методов SetSubtable и SetCardFile класса IFrame теперь нужно напрямую устанавливать свойства

    var Subtable  :ISubtable;
    var CardFile  :Ctrl.ICardFile;

  Например:

      with AddFrame(IFrame.CreateEx("FramePosition")) do
        Subtable = FRecord.Positions;
        ...
      end;


29.11.2018
  -- Осипов Ю.А. 
   - Переименованы имена версий проектов.
     Имена вида 'СИС.ВерсияПроекта' переименованы в 'ВерсияПроекта.СИС', 'Bas.ProjectVersion' в 'ProjectVersion.Bas' и т.д.
     Переименования связаны с оптимизацией кэширования версии проектов при старте сессии.

     Почти во все проектах восстановлены или добавлены имена проектов в классе "Константы" или "Consts", которые были до "революции"
     для избежания "потери" версии и "неожиданной" конвертации данных.

   - Изменение работы profile-ов и srvprofile-ов.
     1. Загрузки и вся конвертация перенесена из profile-ов в консольные расширения srvprofile, в каждом проекте.
        Часть обработчиков, связанные, например с правами доступа, перенесена в серверную часть.
        Сейчас это касается, в первую очередь, ограничения на проводки по "нашему предприятию".

     2. Для одиночной загрузки или для регистрации файлов для групповой загрузки в классе srvprofile добавлена следующая процедура:

          proc Loading (const aUpdate  :Logical);
            var locVersion  :Numeric;

            extended Loading (aUpdate);

            if aUpdate and НоваяИнформационнаяБазаДляПроекта(Consts.ClassProject, Consts.ProjectVersionName, locVersion) then
              -- **************** блок загрузки справочников **********************************
              -- пожалуйста, ставьте дату внесения изменений, чтобы можно было вовремя удалять
              -- ******************************************************************************

              -- **************** блок загрузки справочников **********************************
              -- пожалуйста, ставьте дату внесения изменений, чтобы можно было вовремя удалять
              -- ******************************************************************************
            end;
          end;

        В классе profile для этого использовалась процедура "PreInit".

     3. Для конвертаций и сохранения версий проектов:

          proc DataConversion (const aUpdate  :Logical);
            var locVersion  :Numeric;

            extended DataConversion (aUpdate);

            if aUpdate and НоваяИнформационнаяБазаДляПроекта(Consts.ClassProject, Consts.ProjectVersionName, locVersion) then
              -- **************** блок конвертации старых данных ******************************
              -- пожалуйста, ставьте дату внесения изменений, чтобы можно было вовремя удалять конвертацию
              -- ******************************************************************************

              -- **************** блок конвертации старых данных ******************************
              -- пожалуйста, ставьте дату внесения изменений, чтобы можно было вовремя удалять конвертацию
              -- ******************************************************************************
              УстановитьНовуюВерсиюИнформационннойБазыДляПроекта(Consts.ClassProject, Consts.ИмяВерсииПроекта);
            end;
          end;

        В классе profile для этого использовалась процедура "Init".

     4. В классах profile оставлена старая регистрация дополнительных страниц, различные методы и т.д.
        При этом, все то, что можно было делать раньше, можно и сейчас.
        Т.е. использование загрузок в "PreInit" и конвертации в "Init" возможно, но не желательно.

   - При старте сессии теперь будет задаваться вопрос (или ошибка на вэб-е) о необходимости проведения конвертации.
     Проверка производится с использованием следующей функции, которая должна находиться в серверном расширении класса "Com.Srvprofile":

       func НужнаКонвертацияИнформационнойБазы:Logical;
         Result = extended НужнаКонвертацияИнформационнойБазы or НоваяИнформационнаяБазаДляПроекта(Consts.ClassProject, Consts.ProjectVersionName, nil);
       end;

     По завершению всех конвертаций, при необходимости, будет выведен запрос о перезагрузке программы.
     Также появилась возможность запуска сессии с отложенным "на следующий раз" обновлением.


06.12.2018

Филатов
- Добавлен новый класс-компонент IArray, наследник IValue. Этот класс имеет смысл использовать, когда
  нужно хранить не одно значение, а коллекцию. Например при множественном выборе параметра отчета.
  Значение компонента может быть сохранено в поле/доп.поле записи строкового типа. Для массива записей
  сохраняется строка вида ExtID_1,ExtId_2,...,ExtID_N. При этом ссылочная целостность для выбранных
  значений не поддерживается.

  Пример:

    Products :IArray;

    proc Init;
      ...
      Products = AddComp(IArray.Create);
      Products.FieldName   = 'Products';
      Products.Extra       = True;
      Products.ValueType   = varObject;
      Products.RecordClass = Rec.Product;
      Products.IsSubtable  = True;
      ...
    end;

- Добавлен новый класс-контрол IListEdit, наследник IEdit. Его можно использовать как самостоятельно,
  так и в связке с компонентом типа IArray.

    with AddComp( Ctrl.IListEdit.CreateEx( '', 100, '', ReferenceFormat, varObject, FRecord.Products, 'Name' ) ) as Ctrl.IEdit do
      CardFileClass = Tab.Products;
    end;

  В качестве параметра ValueType нужно указывать не varArray, а тип элемента массива.

  При использовании контрола IListEdit из lookup-картотеки можно выбрать не одну запись, а выделить сразу несколько.
  Если ничего не выделять, то произойдет выбор текущей записи (как в стандартном IEdit).

08.12.2018

Филатов
- Теперь объект типа IArray можно связать с полем-массивом. Для этого в класс добавлено свойство

    var IsSubtable    :Logical;

  Таким образом массив будет сохраняться с поддержкой ссылочной целостности.

  Пример:

    field Products :Ref.Product array Integer;

    Products :IArray;
    ...
    proc Init;
      ...
      Products = AddComp(IArray.Create);
      Products.FieldName   = 'Products';
      Products.IsSubtable  = True;
      Products.ValueType   = varObject;
      Products.RecordClass = Rec.Product;
      ...
    end;

17.12.2018

Филатов
- В класс Ctrl.IFrame добавлено новое свойство

    var Freezed    :Logical;

  Свойство имеет смысл только для табличного фрейма. При установке флага заголовок таблицы замораживается.
  Заморозка работает корректно, если у фрейма с таблицей и всех вышестоящих фреймов свойство AutoSize = False.

- В класс Ctrl.IEdit добавлено новое свойство

    var OneValueChoice            :Logical;

  Если свойство установлено, то для данного контрола работает правило "однозначного ввода" (по аналогии с Т9).
  По-умолчанию OneValueChoice = True.

18.12.2018

Филатов
- В класс IFrame добавлено новое свойство

    var MinSize     :Numeric;

  Свойство имеет смысл выставлять для фреймов, у которых флаг AutoSize = False, например для табличного фрейма.
  При маленьком экране, фреймы с авторазмером могут занять все доступное место и размер табличного фрейма
  схлопнется в ноль. Чтобы этого не происходило, нужно установить ему минимальный размер, меньше которого он уже
  не схлопнется.

20.12.2018

Филатов
- Реформация обработчиков ПриОбзоре и ПриВыводе для IEdit
  Добавлены 3 новые свойства:

    var OnOutput        :TOnOutput;
    var OnOutputCard    :TOnOutputCard;      // аналог OnOutput для картотеки
    var OnLookup        :TOnLookup;

  Если обработчик задан, то вместо стандартной обработки вызывается указанная функция.
  Обратите внимание, что обработка параметров (если она нужна) должна производиться в указанной функции. В частности
  это касается различных OutputTypes.
  Старые методы либо удалены, либо объявлены как Deprecated.

24.12.2018

Филатов
- Для класса Frm.IForm и всех его наследников удален конструктор CreateEx. Теперь везде нужно использовать
  стандартный конструктор Create;


11.01.2019

Адаскин
- Изменена логика работы с флагами Visible и Printed класса IControl
  Теперь установка Visible влияет на Printed

14.01.2019
  -- Осипов Ю.А. 
   - Проект "Зарплата" (т.е. МиниЗарплата) очищен и впоследствии будет удален.
     Все входящие классы записей, операции и журналы перенесены в проект "КонверторИз95".
     Обновление данных через импорт/экспорт. Также добавлена конвертация данных в табличных журналах.

16.01.2019
  -- Осипов Ю.А. 
   - Проекты "Кадры" и "ЗарплатаСтандарт" перенесены в новый проект "Персонал".
     Кадры и Зарплата пока оставлены в качестве заглушки и для автоматического переноса всех данных.
     Впоследствии они будут удалены.
   - Обновлен конвертер из 95.

18.01.2019

Филатов
- В класс IEdit добавлено новое свойство

    var ShortList    :Logical;

  Свойство имеет смысл для полей ссылочного типа. Если ShortList = True, то кнопка обзора (если она
  есть) заменяется на кнопку перечисления, при нажатии на которую отображается список допустимых
  значений (определяется значением поля LookupField). Ручной ввод в поле (если он доступен) работает
  как раньше: если запись определяется однозначно, то подставляется сразу, иначе открывается картотека.
  
Адаскин
- Изменена логика вычисления пользовательских показателей в отчётах.
  Раньше они всегда вычислялись на полную глубину, что существенно замедляло построение.
  Теперь это зависит от свойства CalcAllGroups класса IReport и по умолчанию пользовательские показатели
  вычисляются только для открытых групп.

19.02.2019

Филатов
- Ролевой центр. Доступна настройка на ТБ.Скрипт (не рекомендовано), см. пример ТиС.Cmd.test_ЦУП,
  а также настройка с помощью визуального редактора (рекомендовано), см. пример Control.Cmd.sample_menu.

20.02.2019

Филатов
- В классе ICardForm свойство ShowTree переименовано в

    var HasTree   :Logical;

  Свойство управляет наличием дерева у картотеки.

- Добавлено новое свойство

    var ShowTree  :Logical;

  с помощью которого можно скрыть/показать дерево в картотеке, в частности скрыть дерево при открытии картотеки.
  Если картотека открывается со скрытым деревом, то для нее не сохраняется пользовательская настройка
  "видимость дерева".

- Добавлено новое свойство

    var ExternalTreeFilter        :String;

  Свойство нужно использовать, когда нужно извне установить фильтр на дерево картотеки.

22.02.2019

Филатов
- В классе ICardFile добавлено новое свойство

    var PickOut             :Logical

  При установленном флаге картотека открывается только на выбор, добавление, удаление, редактирование,
  а также открытие бланка редактора запрещены.

28.02.2019

Филатов
- В классе IEdit добавлено новое свойство-событие

    var OnOpenCardForm     :proc(Sender :Ctrl.IEdit; aIndex :Integer; aCardForm :Frm.ICardForm);

  Событием можно пользоваться, когда из поля нужно открыть картотеку используя специальные настройки,
  в частности TreeFilter, PickOut, ShowTree (этих свойств больше нет в IEdit) и т.п.

  Пример:

  Edit_Товар = AddEdit('Товар', 33, FRecord.Товар, 66, ReferenceFormat, 'Name', Tab.Справочники.ТМЦ_Дерево);
  Edit_Товар.OnOpenCardForm = @НастроитьКартотекуТоваров;
  ...


  proc НастроитьКартотекуТоваров(Sender :Ctrl.IEdit; aIndex :Integer; aCardForm :Frm.ICardForm);
    aCardForm.ShowTree = False;
    aCardForm.PickOut  = True;
  end;

06.03.2019

Филатов
- Переименованы классы IValue, IField, IVar, IVarLink, IPeriodicField, IArray. Теперь они находятся в папке Fld,
  т.е. Fld.IValue и т.д.
  Т.к. для основных классов используется переопределение в классе Def, то в надпроектах изменения минимальны.

07.03.2019

Филатов
- Убрал из класса Ctrl.IFrame метод SetInplaceForm. Загрузку формы нужно делать через метод AddComp. Например:

  vTab = FrameTab.AddComp(Tab.Documents.Create);

11.03.2019

Филатов
- Добавлен новый класс Fld.IBlob, наследник Fld.IValue. Класс предназначен для работы с blob-полями, в частности
  с Image.

- Добавлен новый класс контрол Ctrl.IPicture.  Контрол этого класса можно добавить на фрейм и он займет всю
  внутреннюю область фрейма. Фрейм в таком случае имеет FrameType = PictureFrame

Пример (см. проект Demo):

mtl-класс

  field Pict     :Image          title "Изображение";

rec-класс

  Pict  :Fld.IBlob;

  proc Init;
    inherited Init;
    ...
    Pict = Fld.IBlob.Create;
    Pict.CompID    = 'Pict';
    Pict.FieldName = 'Pict';
    AddComp(Pict);
    ...
  end;

frm-класс

  FramePicture :Ctrl.IFrame;
  Picture1     :Ctrl.IPicture;

  proc Init;
    inherited Init;
    ...
    FramePicture = RootFrame.AddFrame(Ctrl.IFrame.CreateEx('FramePicture'));
    FramePicture.AutoSize = False; -- тут авторазмер не подойдет
    FramePicture.Size = 100;
    Picture1 = FramePicture.AddControl(Ctrl.IPicture.Create);
    Picture1.Field = FRecord.Pict;
    Picture1.Stretch = True; -- масштабирование (подгоняем картинку под размер фрейма)
    Picture1.Center  = True; -- центрирование
  end;

20.03.2019

Филатов
- Формула автопересчета компонента. Аналог "ленивых пересчетов".
  Для класса Fld.IValue добавлено новое свойство

    stored var OnCalc     :func(aSender :Fld.IValue) :Variant;

  Это функция, реализующая формулу расчета значения для текущего компонента (если таковая имеется).
  В качестве параметра передается компонента, для которой происходит расчет значения, чтобы можно
  было использовать одну функцию для расчета разных компонент.
  Установка OnCalc означает, что не требуется инициализация значения компоненты в методе OnRead и
  в пересчетах от зависимых компонент. Компонент автоматически инициализируется при обращении к его
  значению.
  Зависимые компоненты нужно указать явно в атрибуте DependsOn перед описанием функции

    #Attr DependsOn="Comp1,Comp2 ...";

  Пример:

    Price  :IField;
    Amount :IField;
    Sum    :IVar;

    proc Init;
      inherited Init;
      Sum.OnCalc = @Sum_OnCalc;
    end;

    #Attr DependsOn="Price,Amount";
    func Sum_OnCalc(aSender :Com.Fld.IValue) :Variant;
      Result = Price.Value * Amount.Value;
    end;

  В данном примере значение Sum автоматически проинициализируется при открытии, а также будет автоматом
  изменяться при изменении Price или Amount.
  При этом если переменную Sum не отобразить на форме, то ее значение не будет инициализироваться при
  открытии, а вычислится только если кто-то к ней обратиться.

  Для более оптимальной работы с IRecord/IStruct нужно вместо инициализации в OnRead и использования
  пересчета OnInput, задавать для компонента OnCalc и список зависимостей.

  P.S. Пока в зависимостях можно указать только компоненты из того же контейнера, что и пересчитываемый.
  Задать например пересчет сумм в позициях при изменении скидки в шапке не получится. Это будет добавлено
  позже.


20.03.2019

Филатов
- В класс ICardForm добавлено новое свойство:

    var Root                :Record

  Если свойство указано, то в дереве картотеки отображаются только группы, начиная от ветки Root и ниже.
  Если при этом дерево фильтрует по полю GroupDoc, то Root аналогичным образом влияет и на поведение картотеки.
  Если требуется указать разные Root для дерева и картотеки, то свойства можно указывать напрямую:

    CardFile.Root = ...
    CardTree.Root = ...

  Пример:

    РесурсОткуда_ТиС = AddFieldCol( "@Наименование ТМЦ" , 40, aDefPos.РесурсОткуда, "Name", Tab.Справочники.ТМЦ_Дерево );
    РесурсОткуда_ТиС.OnOpenCardForm = @РесурсОткуда_ТиС_OnOpenCardForm;


    proc РесурсОткуда_ТиС_OnOpenCardForm(Sender :Ctrl.IEdit; aIndex :Integer; aCardForm :Frm.ICardForm);
      aCardForm.Root = Com.inbase.РесурсВсеТМЦ.ЗначениеСсылочный;
      --aCardForm.CardFile.Root = Com.inbase.РесурсВсеТМЦ.ЗначениеСсылочный;
    end;

19.04.2019

Филатов
- В классе ICardFile добавлено новое свойство

    var ShowDeleted           :Logical


30.04.2019

Адаскин
- В классе IReportForm добавлено свойство StoreControls :Logical
  Оно определяет, будет ли производиться загрузка/сохранение введённых пользователем значений контролов.
  Имеет значение true при открытии отчёта в отдельном окне (кроме уточняющих) и false в остальных случаях.

  При установке свойства в true производится загрузка сохранённых значений.


06.05.2019

Филатов
- Для использования обработчика OnClick через визуальный редактор все места с его использованием приведены
  к единому стилю. Обработчик указывается через свойство

    stored var OnClick            :TOnClick;

  и имеет формат

    type TOnClick        = proc(aSender :Ctrl.IControl; aIndex :Integer);

  Регистрация обработчика через методы AddOnClick и AddOnClickEx отменена.

- Реализована возможность обрабатывать нажатие на заголовок таблицы.
  Для этого в класс IColumnsGroup добавлено свойство

    stored var OnClick            :TOnClick;

  Также для визуальной настройки "кликабельных" клеток заголовка для IColumnsGroup добавлено свойство

   stored var StaticStyle         :consts.StaticStyles;

  В данном случае имеет смысл устанавливать значение StaticHeader.

  Чтобы установить свойства для заголовка столбца таблицы (в частности обработчик OnClick), нужно этот
  столбец положить в фиктивную группу IColumnsGroup. Фиктивная группа - это группа без заголовка,
  внутри которой только один элемент. Такая группа не имеет визуального отображения, но ее свойства
  передаются заголовку элемента.

  Пример настройки можно посмотреть в проекте Demo в бланке Frm.InvoiceRes.

  P.S. Устанавливать обработчик OnClick для реализации сортировки таблицы не нужно. Для этого будет
  специальное свойство.

07.05.2019

Филатов
- В классе IFrame добавлено новое свойство

    stored var Sortable           :Logical;

  Свойство имеет смысл только для FrameType = TableFrame.
  При установленном флаге все заголовки негрупповых столбцов получают стиль StaticHeader и при нажатии
  на такой заголовок происходит сортировка таблицы. Повторное нажатие на заголовок приводит к обратной
  сортировке.
  Если для заголовка столбца (см. предыдущий пост) указан собственный обработчик OnClick и/или свойство
  StaticStyle, то эти свойства перекрывают стандартные. Таким образом для конкретных столбцов можно
  отменить сортировку или сделать другую реакцию на клик по заголовку. Или изменить стандартный стиль
  StaticHeader на другой.

23.05.2019

Филатов
- Сохранение документов теперь по умолчанию происходит без транзакции. Если нужно, чтобы одновременно
  с сохранением текущего документа произошли изменения в другом(их) документах (в рамках одной
  транзакции) нужно явно указать классы записей (IRecord) по которым необходимо открыть транзакцию.

  Например, нужно при сохранении договора обновить банковские реквизиты по договору:

    FRecord.AddTransactionRecordClass([Rec.Документы.Покупки.ДоговорПокупки, Biz.Rec.Data.BankDetails])

- Добавлена возможность создавать табличные IFrame, не привязанные к ISubtable, и связывать их с
  массивами IArray. Это имеет смысл в простых случаях, когда в рамках строки нет никаких пересчетов.

  Пример:

  var Array     :Fld.IArray;   -- отображаемый массив

  var Table_Frame :Ctrl.IFrame;

  proc Init;
    inherited Init;

    Array = AddComp(Fld.IArray.Create);
    -- далее нужно указать тип значения для массива, например
    Array.ValueType   = varObject;
    Array.RecordClass = Rec.Data.Entity;

    Table_Frame = RootFrame.AddNewFrame('Table_Frame');
    Table_Frame.FrameType = TableFrame;   -- явно указываем, что это табличный IFrame
    -- далее явно указываем свойства таблицы: Numbering, CanInsert, CanDelete и т.д.
    ...
    -- добавляем в таблицу столбец и привязываем к нему массив
    vEdit = Table_Frame.AddComp( Ctrl.IEdit.CreateEx( , 50, 'Субъект', ReferenceFormat,, Array, 'Name' ) );
    ...
  end;

  proc DoShow;
    -- заполняем массив
    ...
    Table_Frame.TableRowsCount = Array.Count;  -- явно указываем количество строк в таблице
    inherited DoShow;
  end;

  Для работы с классом IArray добавлены методы:

    proc Delete(aIndex :Integer);
    proc Add(aValue :Variant);
    proc Insert(aIndex :Integer; aValue :Variant = nil);
    func GetItem(aIndex :Integer) :Variant;
    proc SetItem(aIndex :Integer; aValue :Variant);
    func Count :Integer;

18.06.2019

Адаскин
- В классе IIndicator добавлен метод
    SetValueEx(aPart :TSumParts; aSource :Variant)
  Служит для заполнения значения пользовательского показателя по источнику:
    если aSource - строка, то присваиваемое значение берётся из показателя отчёта по имени
    если aSource - целое, то присваиваемое значение берётся из показателя отчёта по индексу
    если aSource - Rep.IIndicator, то то присваиваемое значение берётся из него

- Некоторое время назад в IReportForm добавлены методы
    func ValueByIndex(aSumPart :TSumParts; idx :Integer = 1; aValPart :TValueParts = vpValue) :Variant;
    func ValueByName(aSumPart :TSumParts; aName :String; aValPart :TValueParts = vpValue) :Variant;
  Возвращают значение показателя по порядковому номеру и имени соответственно.

  Для измерителей тип возвращаемого значения определяется параметром aValPart и может быть
    vpAll   - измеритель
    vpValue - значение измерителя (по умолчанию)
    vpUnit  - единица измерения (справочник)

  Все эти методы служат для упрощения формул вычислимых показателей.

04.07.2019

Адаскин
- В класс IEdit добавлен обработчик OnDraw
  Пример использования:

  xxxEdit.OnDraw = proc(aSender :Ctrl.IControlCell; aIndex :Integer; aSelected :Logical)
    aSender.FontSize = 8 + aIndex - 1;
    aSender.FontBold = (aIndex < 3);
  end;

Филатов
- В класс ICardForm  добавлено новое свойство

    var ViewFilter          :String

  Свойство можно использовать, когда в картотеке нужно видеть один набор записей, но выбрать при этом
  можно только часть из них. Например, чтобы были видны промежуточные группы, но выбрать можно было
  только конечные записи.

  Пример:

    Склад = AddFieldEdit( "@Склад" , Frecord.ОбщПроцессОткуда ,, "Name", Tab_Склад, True );
    Склад.OnGetLookupFilter = 'IsGroup = 0 and ТипПроцесса = ' +str(inbase.ТипПроцесса_Склад_ТиС) + ' and НашеПредприятие = ' + str(Company_);
    Склад.OnOpenCardForm = @НастроитьКартотекуСклады;
    ...

    proc НастроитьКартотекуСклады(Sender :Ctrl.IEdit; aIndex :Integer; aCardForm :Frm.ICardForm);
      ...
      aCardForm.ViewFilter = 'ТипПроцесса = ' +str(inbase.ТипПроцесса_Склад_ТиС) + ' and НашеПредприятие = ' + str(Company_);  ;
    end;

  При попытке выбрать запись, не удовлетворяющую фильтру, будет генерироваться исключение "Выбранная запись не удовлетворяет фильтру".
  Если отключить иерархический вид картотеки, то фильтр изменяется, чтобы остались только доступные для выбора записи.
  Значение для ViewFilter нужно указывать полностью, включая те записи, которые доступны для выбора.

05.07.2019

Филатов
- В классы IEdit и ICheckBox добавлено новое свойство-событие

    stored var OnVerify           :TOnVerify;

    type TOnVerify = func(aSender :Ctrl.IControlCell; aIndex :Integer; var aValue :Variant) :Logical;

  В обработчике можно проверить вводимое значение и вернуть False, если нужно предотвратить дальнейший
  ввод или True, если все правильно.

12.07.2019

Филатов
- Визуальный редактор: при добавлении контролов IEdit и IEditEx на обычный (нетабличный) фрейм перед ними автоматически добавляется контрол
  IStatic (заголовок). Значение заголовка берется из свойства Caption. Ширина берется как первое ненулевое значение из списка:
    - CaptionWidth из самого IEdit (IEditEx)
    - CaptionWidth из группы (IGroup), если контрол лежит в группе
    - CaptionWidth из формы, на которой лежит контрол
    - константа StdLabelWidth
  По умолчанию надпись выравнивается по правому краю. Для конкретных форм можно изменить умолчание: свойство CaptionAlign у формы.
  Если требуется добавить IEdit без заголовка, то нужно установить значение HasCaption = False
  Если значения по умолчанию для заголовка не подходят и нужно донастроить его свойства, то нужно отключить заголовок (HasCaption = False)
  и вручную добавить IStatic в нужное место с нужными параметрами.
  P.S. Все вышеописанное касается только настройки через визуальный редактор. При программном формировании формы все работает как и раньше

15.07.2019

Адаскин
- Свойство ListAsString класса IEdit выведено в визуальный редактор
  Свойство служит для заполнения значений перечислимых полей.
  Может заполняться в двух форматах:
    - ['Груша|0', 'Яблоко|1', 'Лимон|3']
    - Груша|0;Яблоко|1;Лимон|3

22.07.2019

Филатов
- В класс ICardTree добавлено свойство

    var TreeOrder    :String;

  Если свойство задано, то элементы дерева сортируются в указанном порядке, иначе упорядочиваются по отображаемому полю.

23.07.2019

Филатов
- В классе IControlCell изменен формат обработчика OnDraw

    type TOnDraw         = proc(aSender :Ctrl.IControlCell; aIndex :Integer; aSelected :Logical; var aColor, aCellColor :Integer; aFont :Ctrl.IFont);

  Соответственно менять в нем теперь надо не свойства контрола aSender, а локальные параметры aColor, aCellColor и свойства объекта aFont.

- В класс IControlCell добавлен обработчик OnColumnDraw

    var OnColumnDraw       :TOnDrawCard;

    type TOnDrawCard     = proc(aSender :Ctrl.IControlCell; aRec :Rec.IRecord; aSelected :Logical; var aColor :Integer; aFont :Ctrl.IFont);

  Обработчик аналогичен OnDraw, но используется для столбца картотеки.

24.07.2019

Филатов
- В класс IControlCell добавлено свойство

    var CanSort       :Logical := True;

  Свойство имеет смысл для столбца картотеки и столбца подтаблицы. В подтаблице по колонке можно сортировать если одновременно установлены
  Sortable у IFrame и CanSort у IEdit/ICheckBox.

- В класс ICardfile добавлено свойство

    var GroupsFirst   :Logical := True;

  Если свойство сброшено, то группы и листовые элементы идут вперемешку в порядке заданной сортировки.

- В класс IEdit добавлено свойство

    var LookupOrder    :String;

  Свойство указывает упорядочивание при формировании "короткого" списка и автодополнения. В свойстве можно указывать одно или несколько полей
  записи(!), а также символы +/- для указания прямого/обратного порядка.
  Примеры:

    EditCustomer.LookupOrder = 'Priority-,Name'     -- сначала наиболее приоритетные, внутри одного приоритета по алфавиту
    EditProduct.LookupOrder = 'Price-'              -- вначале самые дорогие

- В класс ICardTree добавлен обработчик

    var OnClick        :TOnClickTree;

    type TOnClickTree  = func(aSender :Ctrl.ICardTree; aAction :ClickTypes; aRec :Rec.IRecord) :Logical;

31.07.2019

Филатов
- В классы ICardFile и ICardTree добавлен метод

    proc Refresh;

  Метод нужно вызывать когда требуется программно обновить содержимое картотеки/дерева.

07.08.2019

Филатов
- Удалил методы AddOnShow и AddOnClose. Пользуйтесь событиями OnShow и OnClose.

19.08.2019

Филатов
- В класс IEdit добавлено событие

    var OnAutocomplete     :func(aSender :Ctrl.IEdit; aIndex :Integer; aMask :String) :List;

  Событие можно использовать для реализации нестандартного поведения автодополнения или автодополнения для нессылочных полей.
  Пример автодополнения для выбора счета в отчете (см. проект Bas extReportForm и extUtils):

    func Account_OnAutocomplete(aSender :Com.Ctrl.IEdit; aIndex :Integer; aMask :String) :List;
      Result = Com.Utils.GetAccuontList(FReport.AccountPlan, aMask + '*');
    end;

    func GetAccuontList(aPlan, aMask :String; aTypes :String = ""; aLimit :Integer = 0) :List;
      var vAccs = AccFunctions.ReadAccs(aPlan, aMask, aTypes, aLimit);
      Result = Kernel.List.Create;
      for var i = 1..LengthOfArray(vAccs) do
        Result.Add( [ vAccs[i].Name ] );
      end;
      Result.Sort;
    end;

23.08.2019

Адаскин
- В IReport изменён формат обработчика OnSplitEdit
  func (aRep :Rep.IReport; Rec :Record; ObjVal :Variant; aDim :Report.RepDimensions) :Logical
  добавлены параметры:
    aRep - отчёт в котором это происходит
    aDim - вид уточняемого разбиения

30.08.2019

Филатов
- Методы OnPost и OnCancel класса Frm.IEditor переименованы в DoPost и DoCancel

05.09.2019

Адаскин
- Чтобы отчёт не сохранял свои параметры необходимо использовать конструктор CreateExplain (вместо Create)
  Это необходимо для сервисных отчётов в формах (по аналогии с уточняющими отчётами).

06.09.2019

Адаскин
- Свойство AutoBuild класса IReportForm получило геттер и сеттер.
  Теперь его не нужно перекрывать в наследниках.

  Чтобы отчёт автоматически строился при открытии, устанавливаем AutoBuild = true при создании
  (в наследниках - в методе SetDefault).

13.09.2019

Филатов
- В классы IEdit и ICheckBox добавлено новое свойство-событие

    stored var OnEnter            :TOnEnter;

    type TOnEnter = func(aSender :Ctrl.IControlCell; aIndex :Integer; aAction :EnterTypes) :Logical;

  В обработчике можно специальным образом обработать очистку значения (Action = Clear) или вставку из
  клипборда (Action = Paste), а также запретить вход в клетку (имеет смысл для подтаблицы). Например:

    func EditPrice_OnEnter(aSender :Com.Ctrl.IControlCell; aIndex :Integer; aAction :Com.Consts.EnterTypes) :Logical;
      var vStruct :Rec.Invoice_Position = EdtRec.Positions.Items[aIndex];
      Result = not Match(vStruct.Product.Inner.Name, 'tv*');  -- запрещаем изменять цену у TV
    end;

  Обработчик пока срабатывает только для нативного клиента.

- В класс IForm добавлено свойство

    stored var PrintSettings :String;

  С помощью него можно указать нестандартные настройки печати. Соответствующие настройки должны находиться в
  Приложениях к проекту. Например:

    PrintSettings = 'Com.Printers.Альбомная.cfg';

  Настройка пока работает только для нативного клиента.


24.09.2019

Русов
- Изменен способ задания языка при логине. Теперь язык должен передаваться форонтендом до логина,
  в том же вызове, что и ИмяПользователя/Пароль.

  Пока старая версия фронтенда этого не делает, язык можно задать в строке имени пользователя в формате:

  ИмяПользователя|en

26.09.2019

Филатов
- Добавлен новый класс-компонент Fld.ILink, наследник Fld.IValue. С помощью него можно обращаться и редактировать
  поля по ссылке. Например, находясь в Сделке редактировать поля Договора.


    Agreement               :IField;
    AgreementDate           :ILink;     -- редактирование поля BegDate у Agreement

    AgreementDate = AddComp(ILink.CreateEx('AgreementDate', Agreement, 'BegDate', varDate));

    AgreementDate.Value = Today;   -- устанавливаем дату договора в Сегодня

  Поля типа ILink можно связывать с IEdit, тогда на форме будет отображаться значение по ссылке. С помощью этого
  можно задавать форматные преобразования ссылочных полей (раньше можно было задать только с помощью обработчика
  OnOutput), а также напрямую редактировать значения по ссылке (без открытия нового бланка-редактора).
  Внимание! Сохранение изменений, сделанные с помощью редактирования по ссылке, остаются "на совести" у настройщика
  формы. Т.е. нужно запомнить записи, где были проделаны изменения и сохранить (или отменить) их совместно с
  основной записью. Для этого удобно воспользоваться объектом класса Rollback.

- В класс IValue добавлено новое свойство-событие

    stored var OnChange            :proc(aSender :Fld.IValue);

  Это аналог метода AddOnInput, который удобно использовать в визуальном редакторе.

- В класс ISubtable добавлено новое свойство-событие

    stored var OnAfterDelete       :proc(aSender :ISubtable);

  Событие вызывается, после удаления одной или нескольких строк подтаблицы. Его можно использовать например для
  подсчета итогов по подтаблице.


08.10.2019

Адаскин
- В класс IReport добавлен метод:

    #help 'описание текущей клетки';
    func CurDescription(aShowName :Logical = true) :String;

  В описание включаются значения разбиений по всем разрезам в виде
    Ресурс: Гвозди жидкие

  Если параметр aShowName равен false, то в описание включаются только значения разбиений:
    Гвозди жидкие

- В класс IReportForm добавлены свойства и методы:

    #help 'контролы включаемые в описание';
    var IncludeInDescription :Ctrl.IControlCell[];

    #help 'описание заполненных параметров отчёта';
    func ParamsDescription(aExplain :Rep.IReport = nil) :String;

    #help `подзаголовок, отображается между параметрами и собственно отчётом`;
    var Subhead       :String;

  В описание попадают все не пустые визуальные компоненты связанные с IRepControl, а так же не пустые
  контролы перечисленные в массиве IncludeInDescription.

  Если в ParamsDescription передан параметр aExplain, то он рассматривается как уточняемый отчёт и в описание
  включается описание текущей клетки - aExplain.CurDescription.

  Описание параметров возвращается в виде:
    Предприятие: ООО "Лидер", Документы: Исключая внутрихолдинговые документы, Только в учетной валюте

- Добавлен параметр aShowSubhead в метод ShowExplaination класса IReportForm

    func ShowExplaination(Sender :Rep.IReport; IndicatorIndex :Integer; SumKind :Report.SumKinds; DebCre :Report.SumDebCre;
                          ObjVal :Variant; aShowSubhead :Logical = false; aWindowStyle :WindowStyles = StackedWindow) :Frm.IReportForm;

  Если aShowSubhead = true, то у открываемого отчёта заполняется подзаголовок
    Subhead = Sender.CurDescription(false);


14.10.2019

Адаскин
- Добавлен класс Bas.Ctrl.IAccEdit реализующий выбор счёта (ограничения на счета)
  В нативном клиенте работает автокомплит, а по кнопке открывается диалог выбора счетов.
  В веб клиенте - только автокомплит (планировался выбор из списка, но его размеры этого не позволяют).

- Для удобства использования добавлены "обёртки" (как расширения в проекте Bas):

  Com.Ctrl.IControlsLayout
    func AddAccEdit(aAccPlan, aAccMask :String; aLabel :String = ''; aLabWidth :Numeric = 0; aField :Fld.IValue; aWidth :Numeric = 0) :Ctrl.IAccEdit;

  Com.Frm.IReportForm
    func AddAccEdit(aLabel :String = ''; aLabWidth :Numeric = 0; aField :Rep.IRepControl; aWidth :Numeric; aMask :String = '') :Ctrl.IAccEdit;

21.10.2019

Филатов
- В классе Fld.IPeriodicField вместо функций

    func Items(aDate :Date) :Variant;
    func IndexByNumber(aNumber :Integer) :Date;
    func NumberByIndex(aDate :Date) :Integer;

  теперь есть одноименные индексные свойства

    var Items[aDate :Date]              :Variant;
    var IndexByNumber[aNumber :Integer] :Date;
    var NumberByIndex[aDate :Date]      :Integer;

  Свойство Items[] доступно и на чтение и на запись, другие только на чтение.
  Методы

    func GetValueForDate(aDate :Date) :Variant;
    proc SetValueForDate(aValue :Variant; aDate :Date);

  удалены за ненадобностью.

- В классах ISubtable, Fld.IPeriodicField и ISubContainer свойство Items объявлено как Default. Т.е. его можно опускать.
  Например вместо

    Валюта.Курс.Items[Today]

  можно писать

    Валюта.Курс[Today]

24.10.2019

Филатов
- В класс ICardFile добавлено новое событие

    stored var OnDrawRow              :proc(aRec :Rec.IRecord; aSelected :Logical; var aColor :Integer; aImage :Image);

  С помощью него можно изменять стандартную иконку, а также цвет фона иконки. Например:

  -- подкрашиваем строку цветом статуса
  proc CardFile_OnDrawRow(aRec :Com.Rec.IRecord; aSelected :Logical; var aColor :Integer; aImage :Image);
    var vRec :Rec.Document = aRec;
    if vRec.Status.Value <> nil then
      aColor = vRec.Status.Inner.Color;
    end;
  end;

  -- изменяем иконку у валют
  proc CardFile_OnDrawRow(aRec :Com.Rec.IRecord; aSelected :Logical; var aColor :Integer; aImage :Image);
    var vRec :Rec.UnitOrCurrency = aRec;
    if vRec.IsCurrency.Value = True then
      aImage.Assign(IconCurrency);
    end;
  end;

13.11.2019

Адаскин
- Свойства SplitParams и SplitItems класса IReport объявлены устаревшими и стали доступны только на чтение
  Вместо них рекомендуется использовать SplitByTabs, SplitByRows, SplitByCols, ContentByTabs, ContentByRows, ContentByCols соответственно

  Например, вместо
    Result = FReport.SplitParams[Report.rdCol, idx];
  следует писать
    Result = FReport.SplitByCols[idx];

14.11.2019

Филатов
- В класс IFrame добавлены новые события

    var OnInsert                  :TOnInsert;
    var OnDelete                  :TOnDelete;
    var OnChangePosition          :TOnChangePosition;

    type TOnInsert         = func(aSender :Ctrl.IFrame; aIndex :Integer) :Logical;
    type TOnDelete         = func(aSender :Ctrl.IFrame; aIndex :Integer) :Logical;
    type TOnChangePosition = func(aSender :Ctrl.IFrame; aIndex :Integer; aMoveUp :Logical) :Logical;

  События имеют смысл только для табличного фрейма. Если функция-обработчик возвращает True, то продолжается стандартное действие
  (добавление/удаление/смена позиций местами). Если в обработчике нужно "вручную" вызвать действие (добавление/удаление/смена позиций местами),
  то нужно вызвать один из методов

    proc InsertPos(aIndex :Integer; var aStruct :IStruct = nil; aSetPos :Logical = True);
    proc DeletePos(aIndex :Integer);
    proc PosUp(aIndex :Integer; aSetPos :Logical = True);
    proc PosDown(aIndex :Integer; aSetPos :Logical = True);

  Если планируется несколько подряд вставок/перемещений, то нужно передать параметр SetPos = False для всех вставок/перемещений, кроме последнего
  Пример:

    #Override;
    proc Init;
      inherited Init;
      FramePositions.OnInsert = @Positions_OnInsert;
    end;

    func Positions_OnInsert(aSender :Ctrl.IFrame; aIndex :Integer) :Logical;
      Frm.Dlgs.EnqOkCancel('Добавить позицию?').OnFinish =
        proc(aCommand :Integer)
          if aCommand = consts.cmOk then
            var vStruct :Rec.Invoice_Position;
            aSender.InsertPos(aIndex, vStruct);
            vStruct.Amount.Value = 1;
          end;
        end;
      Result = False;
    end;

26.12.2019

Филатов
- В класс ICardFile добавлено новое событие

    stored var OnOpenBlank              :func(aAction :Consts.OpeningRecordType; aRec :Rec.IRecord) :Logical;

  С помощью обработчика можно реализовать нестандартное поведение в момент открытия записи или дополнить стандартное поведение
  дополнительными действиями. Если обработчик возвращает True, то выполняются стандартные действия.
  Пример. В картотеке отчетов вместо настроек отчета открываем сам отчет:

    func CardFile_OnOpenBlank(aAction :Consts.OpeningRecordType; aRec :Com.Rec.IRecord) :Logical;
      if aAction = Consts.ortNormal then
        Rep.Viewer.Open(aRec);
      else
        Result = True;    -- для создания и дублирования открываем настройку отчета
      end;
    end;

- В класс ICardTree добавлены новые события

    stored var OnCreateRecord    :proc(aRec :Rec.IRecord);
    stored var OnOpenBlank       :func(aAction :OpeningRecordType; aRec :Rec.IRecord) :Logical;

  Назначение и использование аналогично одноименным событиям класса ICardFile

13.01.2020

Адаскин
- Добавлен диалог множественного выбора Services.Multiselect (аналог Alternate с возможностью выбора нескольких элементов)

  Пример:
    var аВсеВарианты, аВыделенные :String[];
    var аЗамыкание :proc(aSelected :String[]);
    Services.Multiselect.ShowFormEx(аВсеВарианты, аВыделенные, аЗамыкание);

- В класс Ctrl.IListEdit поддержан множественный выбор для строковых переменных.
  По кнопке используется диалог Services.Multiselect
  При наборе поддержано автодополнение.
  Не позволяет выбрать элемент отсутствующий в наборе.
  Пример использования: см. MSList в классе РСБУ.Rep.ОбщиеОтчеты.КарточкаСчета_А

- Для удобства использования добавлена "обёртка" в Ctrl.IControlsLayout
  aFullSet - список доступных элементов

    func AddMultiSelect(aLabel :String = ''; aLabWidth :Numeric = 0; aField :Fld.IValue; aWidth :Numeric = 0; aFullSet :String[]; aHint :String = '') :Ctrl.IListEdit;


18.02.2020

Адаскин
- В классе IChart поддержаны новые возможности класса Chart (bin308-309) и изменён интерфейс добавления серий.
  Пример использования:
    var vSeries = FChart.AddSeries(vKind, vCaption, vValuesCount);
    for var x = 1..vValuesCount do
      vSeries.PutValue(x, f(x), Str(x));
    end;

  Методы заполняющие серии по данным отчёта BarsFromXXX остались без изменений.

- В классе IRepControl добавлено свойство DoNotSave :Logical
  Установка в true позволит не сохранять параметр между сессиями


08.04.2020

Филатов
- В класс ICardFile добавлены новые события

    stored var BeforeModify           :func(aSender :Ctrl.ICardFile; aAction :ModifyActions; aRec :Rec.IRecord; aGroup :Rec.IRecord) :Logical;
    stored var OnModify               :func(aSender :Ctrl.ICardFile; aAction :ModifyActions; aRec :Rec.IRecord; aGroup :Rec.IRecord) :Logical;

  Событие BeforeModify происходит перед началом изменения (удаление, восстановление, перемещение, копирование) одной или нескольких выделенных
  записей. Независимо от того вызывается действие для одной или нескольких записей, событие BeforeModify происходит только один раз. При этом,
  если действие вызывается для выделенных записей, то обратиться к ним можно с помощью метода Selected.
  Если обработчик события BeforeModify возвращает True, то на каждую запись вызывается событие OnModify. Иначе выполнение действия над записями
  прекращается.
  Если обработчик события OnModify возвращает True, то выполняются стандартные действия над записью. Иначе запись не обрабатывается.
  Пример:

    func CardFile_BeforeModify(aSender :Com.Ctrl.ICardFile; aAction :ModifyActions; aRec :Com.Rec.IRecord; aGroup :Com.Rec.IRecord) :Logical;
      if aAction = DeleteRecord then
         if aSender.SelectedCount > 5 then
           Com.Frm.Dlgs.Message('Нельзя удалять более пяти записей');
           aSender.Selected = nil;  -- снимаем выделение
         else
           Result = True;
         end;
      else
        Result = True;
      end;
    end;

    func CardFile_OnModify(aSender :Com.Ctrl.ICardFile; aAction :ModifyActions; aRec :Com.Rec.IRecord; aGroup :Com.Rec.IRecord) :Logical;
      if aAction = CopyRecord then
        -- пометим запись как дубликат
        aRec.Comment = 'Это дубликат';
      end;
      Result = True;
    end;


12.05.2020

Адаскин
- В класс ISplitContent добавлены свойства

    var Split            :Rep.ISplitParam; -- разбиение с которым связан элементом вывода
    var ReportIndex      :Integer;         -- порядковый номер разбиения

- В классы ISplitContent и IIndicator добавлено событие OnPaint
  Служит для раскраски клеток отчёта.
  На текущий момент реализовано только для нативного клиента. Серверная реализация ожидается.

  Пример для ISplitContent:
    OnPaint = proc(aSender :Com.Rep.ISplitContent; var aColor, aFontColor :Integer)
      var vRep = aSender.Owner;
      var vScale = (vRep.CurRow - 1) / vRep.RowCount;
      if vScale >= 0 then
        var vDeltaR = Int(128 * vScale);
        var vDeltaG = Int(-96 * vScale);
        var vDeltaB = Int(128 * vScale);
        aColor = Utils.RGB(52, 239, 72) + Utils.RGB(vDeltaR, vDeltaG, vDeltaB);
      end;
    end;

08.04.2020

Филатов
- В класс ICardTree добавлены новые события

    stored var BeforeModify           :func(aSender :Ctrl.ICardTree; aAction :ModifyActions; aRec :Rec.IRecord; aGroup :Rec.IRecord) :Logical;
    stored var OnModify               :func(aSender :Ctrl.ICardTree; aAction :ModifyActions; aRec :Rec.IRecord; aGroup :Rec.IRecord) :Logical;

  События аналогичны соответствующим событиям ICardFile.

22.06.2020

Адаскин
- В класс IIndicator добавлен метод

    IgnoreIndicatorLimits(aIgnoreSaldo, aIgnoreTurns :Logical = true);

  Показатель для которого вызван метод игнорирует ограничения по остаткам/оборотам и строка отчёт всегда будет переноситься в строку "Прочие"
  (скрываться, если показ строки "Прочие" выключен).

- В класс IWrapIndicator добавлены методы

    SetNZSaldo;
    SetNZTurns;
    LimitBy(aIndicators :Rep.IIndicator[]);

  Методы SetNZSaldo/SetNZTurns устанавливают отбрасывание нулевых остатков/оборотов для всех показателей.
  Метод LimitBy объявляет игнорирующими ограничения все показатели, кроме перечисленных.

25.06.2020

Филатов
- В класс IEditor добавлены новые события

  stored var OnPost   :TOnPost;
  stored var OnCancel :TOnCancel;

  type TOnPost   = func(aSender :Frm.IEditor) :Logical;
  type TOnCancel = func(aSender :Frm.IEditor) :Logical;

  В обработчике можно вызвать действия, характерные только для этой формы. Например, вызов SetVisibility.
  Действия, которые нужно делать при любом сохранении/отмене сохранений записи нужно делать в соответствующих
  событиях класса IRecord.

  В обработчиках этих событий, также как и в методах DoPost/DoCancel, доступна глобальная переменная FWithoutClosing.
  Эту переменную можно использовать для условного выполнения действий, которые должны происходить только если форма
  не закрывается после сохранения/отмены записи. Например, вызов SetVisibility.

  Если обработчик события возвращает True, то продолжается стандартная обработка, т.е. запись сохраняется/отменяется.
  Иначе запись останется в предыдущем состоянии.

17.07.2020

Адаскин
- Добавлены умолчания команд управления:

  Для Com.Cmd2.IItem
    если не указан IconName, он берётся из группы

  Для ComManaging.OpenIForm
    если не указан Caption, он заполняется описанием формы, указанной в FormClassName

21.07.2020

Филатов
- В класс IComponent добавлен метод

  proc MoveTo(aComp :IComponent; aMode :ComponentMovementMode = cmmBefore)

  type ComponentMovementMode = (
    cmmBefore,
    cmmAfter,
    cmmInside
  );

  С помощью этого метода можно переместить текущую компоненту:
  - aMode = cmmBefore - перед указанным компонентом
  - aMode = cmmAfter - после указанной компоненты
  - aMode = cmmInside - в конец указанной группы (имеет смысл для перемещения в пустую группу)
  Перемещение можно делать как в рамках одной группы/фрейма, так и из группы в группу.
  Если параметр aComp не указан, то
  - aMode = cmmBefore - перемещение в конец текущей группы
  - aMode = cmmAfter - перемещение в начало текущей группы
  - aMode = cmmInside - не определено (по факту компонент нигде не отобразится)
  Этот метод имеет смысл использовать в расширениях форм, когда нужно добавить новые контролы в произвольное
  место формы.

  Пример:

  SummBox.MoveTo(ExtraBox) - переместить фрейм SummBox на место (перед) фрейма ExtraBox
  ColSaldo.MoveTo(ColQuantity, cmmAfter) - поместить колонку ColSaldo после колонки ColQuantity

27.07.2020

Филатов
- Изменился формат обработчика класса IEdit

  stored var OnEnter   :TOnEnter;
  type TOnEnter        = func(aSender :Ctrl.IControlCell; aContext :IContext; aAction :EnterTypes) :Logical;

  Вместо параметра aIndex :Integer теперь передается объекта Context. Для подтаблицы у этого объекта заполнено
  поле Index, а для картотеки Record (+Inner).
  Таким образом теперь обработчик OnEnter можно использовать в картотеке с inplace-редактированием.
  P.S. Обработчик OnEnter пока не поддерживается на WEB-клиенте ни для подтаблицы ни для картотеки.


10.08.2020

Сущик
- В объекты классов cmd2.IMenu, cmd2.IModule по аналогии с cmd.ICommand добавлено свойство Accessible

  stored var Accessible :Logical;

  Свойство предназначено для управления доступом к меню (модулю) в соответствии с правами доступа.

01.09.2020

Адаскин
- В классы ISplitContent и IIndicator добавлено событие OnUpdateCell
  Служит для изменения свойств клеток отчёта, заменяет OnPaint.
  Событие OnPaint удалено.

  Пример использования для ISplitContent:
    OnUpdateCell = proc (aSender :Rep.ISplitContent; Cell :ReportCell)
      var vRep = aSender.Owner;
      var vScale = (vRep.CurRow - 1) / vRep.RowCount;
      if vScale >= 0 then
        var vDeltaR =  52 + Int(128 * vScale);
        var vDeltaG = 239 + Int(-96 * vScale);
        var vDeltaB =  72 + Int(128 * vScale);
        Cell.Color  = Utils.RGB(vDeltaR, vDeltaG, vDeltaB);
      end;
    end;

08.10.2020

Адаскин
- В проекте Bas добавлена новая сущность "Именованные настройки".
  Это настройки, сохраняемые пользователем, с возможностью быстрого переключения.
    Для отчётов сохраняются: период и значения параметров.
    Для картотек сохраняются: фильтр, упорядочивание, иерархичность, текущая папка, а так же раскладка столбцов.
    Для инфопанелей сохраняются настройки их элементов.

  Настройки хранятся в записи Bas.Config.NamedSettings
  Имя применённой настройки показывается в заголовке окна, в скбоках после имени.

21.10.2020

Адаскин
- В Frm.IReportForm добавлено свойство ReportCaption служащее для установки заголовка формы отчета.

- В проекте Bas добавлен метод AddExtraSplit реализующий выбор доп.разбиений
  (в Т9 для этого использовался базовый отчёт Отчеты.ОтчетСДопАналитикой)

  func AddExtraSplit(aLabel :String; aLabWidth, aWidth :Numeric; aAcc :Com.Rep.IRepControl = nil; aDim :Report.RepDimensions = Report.rdRow) :Com.Ctrl.IEdit;
    aLabel - заголовок
    aLabWidth - ширина заголовка
    aLabWidth - ширина поля
    aAcc - поле отчёта (IRepControl) содержащее ограничение на счета
    aDim - разбиение, к которому добавляется разбиение

  Для инициализации доп разбиений используется метод InitExtraSplits(aEditParams :Logical = false)
  Он должен вызываться после задания параметров разбиения и вывода отчёта (после вызовов AddSplit/AddContent)
  Если aEditParams = true, то все параметры отчёта могут изменяться в редакторе доп.разбиений.

  Примеры использования в проекте РСБУ\СерверныеКлассы
  Rep.ОбщиеОтчеты.КарточкаСчета_А
  Rep.УчетТМЦ.ТМЦ.ОстатокТМЦ

02.11.2020

Адаскин
 - В проект Infoboard добавлен класс Ctrl.IGadget, наследник IPicture
   Датчики служат для визуального отображения данных.

     GadgetType    - тип датчика, на текущий момент поддержаны несколько видов шкал
                     в перспективе возможны датчики с обратной связью: переключатели, кнопки и т.д.
     Value         - значение датчика
     ValueMin      - минимальное значение
     ValueMax      - максимальное значение
     ShowValue     - показывать значение на датчике
     Caption       - надпись на датчике

   Пример использования в Demo.FrmTest.Dashboard
   Так же IGadget используется вместо датчиков в графических отчётах.

05.11.2020

Сущик
Для упрощения работы с подсистемой логирования (протоколирования событий) в экземпляр класса Logging.EventsLog
реализующtuj основной интерфейс протокола событий добавлены методы:

  1proc LogTraceF(aMessage :String; ...aParams)
  Выводит информационное сообщение в протокол

  1proc DumpError(ErrorCode :Integer; const ErrorText :String; const AddInfo :Variant[] = nil);
  Протоколирует ошибку произошедшую в ходе работы системы.
  Параметры:
    - ErrorCode - код ошибки;
    - ErrorText - текст ошибки;
    - AddInfo   - любая дополнительная информация, например значения переменных и т.п.
                  в формате [Ключ1, Значение1, Ключ2, Значение2...].

  1proc DumpInfo(const anInfo :Variant[]; aMessage :String = ''; ...aMessageParams);
  Выводит набор информации в протокол.
  Параметры:
    - anInfo         - любая информация в формате [Ключ1, Значение1, Ключ2, Значение2...];
    - aMessage       - сообщение;
    - aMessageParams - параметры сообщения.`;

В Com.Vars на уровне проекта Bas добавлено свойство CommonLog - ссылка на протокол общих событий.

Пример вывода отладочного сообщения в общий протокол:
1  Com.Vars.CommonLog.LogTraceF('Текущий пользователь: %s', Com.Vars.CurrentUser.Name.Value);

Пример регистрации ошибки в общем протоколе:
1  try
1    MyProc0(Today, Random(100))1;
1  except
  1  0Com.Vars.CommonLog.1DumpError0(1ErrorCode; ErrorText, ['CurrentUser', Com.Vars.CurrentUser.Name.Value]0);
1    raise;
  1end;

Пример вывода информационного дампа в общий протокол:
1  proc MyProc(aDate :Date; aValue :Numeric; ...aParams);
1    Com.Vars.CommonLog.DumpInfo(['Date', aDate, 'Value', aValue, 'AddParams', aParams], 'MyProc in class %s', [ClassName]);
1    MyProcBody;
1  end;

19.11.2020

Филатов
- Для обращения из дочерней формы к родительской в классе IForm есть параметр

  var ReferrerForm  :weakref Frm.IForm;

  В большинстве случаев параметр заполняется автоматически. Но если дочерняя форма открывается "вручную", без использования
  готовых методов, то ReferrerForm также нужно установить "вручную", либо явно:

  var vNewForm = Create ...
  vNewForm.ReferrerForm = Self;
  vNewForm.Show;

  либо через глобальный контекст:

  Com.IApp.ReferrerForm = Self;
  try
    vRec.Open;
  finally
    Com.IApp.ReferrerForm = nil;
  end;

  Глобальный контекст обязательно нужно очистить.
  Если ReferrerForm оставить пустым, то форма откроется в новой цепочке полуформ.


25.11.2020

Филатов
- В класс IEdit добавлен метод

  stored var SetRecordParams    :proc(aSender :Ctrl.IEdit; aIndex :Integer);

 С помощью этого метода можно динамически подменивать свойства CardFileClass и RecordClass, если они заранее неизвестны
 и их можно определить только в момент обращения к IEdit.
 Например, в таблице в первом столбце задается картотека, а во втором - выбирается значение из этой картотеки:

  editValue.SetRecordParams = proc(aSender :IEdit; aIndex :Integer)
    var vCrd = editCrd.GetValue(aIndex);
    aSender.CardFileClass = vCrd;
    aSender.RecordClass   = vCrd?.RecordClass;
  end;

- В класс IFrame добавлено свойство

  var ManualControl             :Logical;

  Свойство управляет соответствующим свойством периодической секции, а именно, если ManualControl = False, то
  запрещено вручную добавлять, удалять и перемещать строчки, а при отсутствии строчек "сервисная строка"
  (строка без данных для начала редактирования подтаблицы) скрыта.
  По-умолчанию, ManualControl = True

11.12.2020

Филатов
- Добавлен новый класс-компонент

  IColorEdit inherited IEdit

  Компонента дает возможность выбрать и отобразить выбранный цвет. Выбрать цвет можно из диалога выбора цвета
  или введя вручную значение. Вводить можно как просто число (если знаешь каким числом обозначается нужный
  цвет), так и значение в формате RGB и BGR (в Турбо цвета задаются в BGR). Например красный цвет можно задать:

  255      -- как число
  #FF0000  -- в формате RGB
  $0000FF  -- в формате BGR

  Для того, чтобы значение 0 не воспринималось как черный цвет, а указывало на то, что цвет не задан, нужно
  для компоненты установить опцию ZeroIsTransparent. В этом случае если явно выбрать черный цвет, то в поле
  запишется значение -1. А если в поле нажать Delete, то значение сбросится в 0 (не задано).

  Указывать с помощью компоненты логические цвета не рекомендуется

  Примеры использования можно посмотреть в проекте Control для форм Ref.TaskImportance и Ref.TaskPriority

24.12.2020

Филатов
- Сортировка таблиц
  Для программной сортировки таблиц в класс IFrame добавлен метод

  proc SortBy(aComparer :func(aSender :IFrame; aIndex1, aIndex2 :Integer) :Integer; aAsscend :Logical = True);

  В параметре aComparer нужно передать функцию сравнения строчек таблицы. Для примеров в классе IFrame реализованы
  две функции сравнения

  func CompareByColumns(aColumns :Ctrl.IControlCell[]; aAsscends :Logical[] = nil) :func(aSender :Com.Ctrl.IFrame; aIndex1, aIndex2 :Integer) :Integer;
  func CompareByFields(aFields :String) :func(aSender :Com.Ctrl.IFrame; aIndex1, aIndex2 :Integer) :Integer;

  Первая производит сравнения по значениям в заданных колонках. При этом с помощью массива aAsscends можно
  указать по каким колонкам делать прямую сортировку, а по каким - обратную. Вторая функция производит сравнение
  по полям подтаблицы, указанным в строке через запятую. При этом поля не обязательно должны отображаться в таблице.
  Например:

  FramePositions.SortBy(FramePositions.CompareByFields('Amount-, Product.Name+'));  -- первичная сортировка по количеству в обратном порядке, вторичная - по имени товара
  FramePositions.SortBy(FramePositions.CompareByColumns([EditAmount, EditProduct], [False, True]));   -- аналогичная сортировка

  Можно написать и использовать свои функции сравнения.

  Для простых случаев можно воспользоваться методом класса IFrame

  proc SortByColumn(aColumn :Ctrl.IControlCell; aAsscend :Logical = True);

  При нажатии на заголовок сортируемой таблицы вызывается как раз этот метод.

28.12.2020

Адаскин
- В ролевых центрах добавлена возможность пользовательской настройки:
    стандартные иконки можно скрывать
    можно добавлять пользовательские команды
    возможно перемещение пользовательских команд (Drag&Drop)
    управление свойствами команд доступно через контекстное меню

  В главном меню, картотеке отчётов и картотеке инфопанелей добавлена команда
  "Закрепить на РЦ", позволяющая создать ярлык выбранного элемента на текущем РЦ.

  Пользовательские команды - это наследники класса Com.ComManaging.IUserCmd
  На сегодня доступны:
    Com.ComManaging.UserCommand         - выполнить команду
    Com.ComManaging.OpenReport          - открыть отчёт из базы
    Infoboard.ComManaging.UserInfoboard - открыть инфопанель
    Com.ComManaging.UserCallProc        - выполнить процедуру

  Чтобы добавить свою, необходим наследник от IUserCmd, в котором будут заполнены свойства:
    CommandName     - имя команды (по умолчанию)
    CommandMenuName - имя пункта контекстного меню
    CommandIcon     - иконка (по умолчанию)
  и перекрыт метод ExecuteUserCommand

19.01.2021

Адаскин
 - Для отчётов по оборотам и по справочникам появилась возможность задавать надпись при пустом отчёте.
   Для этого в классе IReport добавлено свойство EmptyReportCaption

19.02.2021

Филатов
- В класс IFrame добавлено событие

  stored var OnSwitch  :TOnSwitch;
  type TOnSwitch       = func(aSender :Ctrl.IFrame; aSubFrame :Ctrl.IFrame) :Logical;

  Событие имеет смысл для фрейма, у которого субфреймы расположены на закладках.
  Событие вызывается при ручном переключении закладки пользователем. Про программной установке текущего фрейма
  событие не вызывается.
  Если событие возвращает False, то переключения не происходит.
  Если нужно сделать часть действий до момента переключения, а часть действий после переключения, то:

  func Frame_OnSwitch(aSender :Ctrl.IFrame; aSubFrame :Ctrl.IFrame) :Logical;
    -- действия до момента переключения
    aSender.CurrentFrame = aSubFrame;
    -- действия после переключения
    Result = False;  -- запрещаем стандартную обработку
  end;

16.03.2021

Филатов
- Изменились умолчания для видимости дерева картотеки. Теперь
  - если используется crf-настройка, то по-умолчанию дерево видимо и чтобы его скрыть, нужно исключить фрейм FrameCardTree
  - если не используется crf-настройка, то по-умолчанию дерево видно для иерархического класса записи, а для неиерархического - скрыто;
    Чтобы изменить значение по-умолчанию, нужно перед вызовом inherired Init, явно установить HasTree

  Внимание! Из-за изменений умолчания в некоторых картотеках появится дерево и нужно вручную его скрыть.

02.04.2021

Филатов
- Свойства EditorClass и CardformClass в IRecord перенесены в область inclass private, т.е. стали недоступными извне.
  Вместо них нужно пользоваться соответствующими методами GetEditorClass / GetCardformClass.
  В метод GetEditorClass можно передавать как параметр объект IRecord для которого требуется получить бланк-редактор.
  Это нужно для тех случаев, когда в рамках одного класса IRecord используется несколько разных бланков-редакторов.
  В случае, когда нужно получить объект бланк-редактор / картотека, нужно использовать методы GetEditor / GetCardform
  А если нужно просто открыть существующий IRecord в бланке редакторе, то проще использовать метод Show / ShowEx,
  ShowEx позволяет сразу передать Referrer форму как параметр.

08.04.2021

Филатов
- Доработки в мастере фильтра картотеки:
  - теперь при выборе ссылочного значения учитывается фильтр (LookupFilter), описанный в соответствующем поле(!). Например,
    для поля Country класса Resource указан фильтр "IsCountry" и при выборе значения фильтра будут доступные только страны,
    а регионы - нет
  - при выборе ссылочного значения можно воспользоваться выбором из картотеки

16.04.2021

Адаскин
- Рефакторинг Ctrl.IChart
  - Заполнение из отчёта выделено в Ctrl.Chart.FromReport
  - Формирование json для apexcharts выделено в Ctrl.Chart.Apexcharts
  - Удалены старые (нативные) гаджеты

20.04.2021
  -- Осипов Ю.А.
   - В проекте "МашРек" добавлена возможность запуска автоматических расчетов, через новый параметр (ключ) командной строки '/AutoService'.
     Вторым параметром задается код задания ('/AutoService=<Код задания>').
     В класс записей "Настройки.АвтоматическийРасчет", в картотеку и на все бланки настроек добавлено поле "КодЗадания".
   - Найденные константы ключей запуска вынесены в Com.Consts. Сейчас их 3:
       const CommandLineIdRobot        :String = 'idAsyncExec';   -- Запуск робота-исполнителя
       const CommandLineIdDispatcher   :String = 'idDispatcher';  -- Запуск робота-диспетчера
       const CommandLineIdAutoService  :String = 'AutoService';   -- Запуск автоматических расчетов

04.05.2021

Адаскин
- В настройке отчёта содержимое страницы "Иерархия" перенесено на страницу "Дополнительно"

07.05.2021

Филатов
- В класс IEditor добавлено новое событие

  stored var OnVerify :func(aSender :Frm.IEditor) :Logical;

  и аналогичный метод

  func DoVerify :Logical;

  В обработчике/методе можно делать проверки корректности, например заполненность полей, а также устанавливать фокус
  на ошибочные контролы.

  Если обработчик/метод возвращает True, то продолжается стандартная обработка, т.е. вызывается событие OnPost.
  Иначе сохранение прерывается, в частности отменяется закрытие формы.

  В обработчике/методе доступна глобальная переменная FWithoutClosing. Эту переменную можно использовать для условного
  выполнения действий, которые должны происходить только если форма после сохранения не закрывается.

11.05.2021

Филатов
- Компоненты, вложенные в IEditEx теперь не изменяют свою доступность при изменении доступности основного компонента IEditEx.
  Т.е. если есть Edit1 :IEditEx  и внутри него есть But1 :IButton, то при установке

  Edit1.Enabled = False;

  компонент But1 не изменит свою доступность.

  P.S. Значения Visible и Printed у субкомпонент меняются синхронно с соответствующим свойством основной компоненты IEditEx.

12.05.2021

Адаскин
- В Frm.Dlgs добавлен метод EnqYesNoWithFlags вызывающий модальный диалог с кнопками Да/Нет и произвольным набором флагов

  proc EnqYesNoWithFlags(aMessage :String; aFlags :Variant[]; aCallback :proc(aFlags :Logical[]); aCaption :String = ""; aType :Integer = dtQuestion);

  Параметр aFlags принимает массив [Имя 1, Значение 1, Имя 2, Значение 2]
  Замыкание aCallback вызывается только при нажатии Да.

  Пример:
    Frm.Dlgs.EnqYesNoWithFlags('Удалить запись?', ['с проверкой ссылочной целостности', true], proc(aFlags :Logical[])
      if aFlags[1] then
        -- удалять с проверкой
      else
        -- удалять без проверки
      end;
    end);

Филатов
- В обработчик события OnAutocomplete класса IEdit добавлен параметр Limit:

  stored var OnAutocomplete     :func(aSender :Ctrl.IEdit; aIndex :Integer; aMask :String; aLimit :Integer) :List;

  Параметр задает ограничение на количество элементов в списке.
  Рекомендуется в пользовательских обработчиках поддержать этот параметр.

24.05.2021

Адаскин
-  В свойствах StringValueObf и StringValueEdt класса Com.Rec.Config.Setting использовано приведение типов

-  Изменен интерфейс работы с якорями Bas.Rec.Config.Anchor (бывший Bas.Rec.Config.Participant)

==================================================================================================================
дальнейшие записи см. файл Changelog.md
==================================================================================================================